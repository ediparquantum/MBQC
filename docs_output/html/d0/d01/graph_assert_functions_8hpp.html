<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MBQC: src/testFunctions/graphAssertFunctions.hpp File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../mbqc_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">MBQC<span id="projectnumber">&#160;0.01</span>
   </div>
   <div id="projectbrief">Measurement Based Quantum Computation (MBQC) using QuEST</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d0/d01/graph_assert_functions_8hpp.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">graphAssertFunctions.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a href="../../d0/d01/graph_assert_functions_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a60966966368ac25fe48dbccd70490e98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d01/graph_assert_functions_8hpp.html#a60966966368ac25fe48dbccd70490e98">assertHandShakeLemma</a> (const <a class="el" href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:a60966966368ac25fe48dbccd70490e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts the Handshake Lemma for an undirected graph.  <br /></td></tr>
<tr class="separator:a60966966368ac25fe48dbccd70490e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781ea29934c2f8c5c65a73075bc13da1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d01/graph_assert_functions_8hpp.html#a781ea29934c2f8c5c65a73075bc13da1">assertPathGraphMinMaxDegrees</a> (const <a class="el" href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:a781ea29934c2f8c5c65a73075bc13da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts the minimum and maximum degrees for a path graph.  <br /></td></tr>
<tr class="separator:a781ea29934c2f8c5c65a73075bc13da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b459ddc7c532fc5a37abb8760d7ca6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d01/graph_assert_functions_8hpp.html#ab7b459ddc7c532fc5a37abb8760d7ca6">assertDegreeSetLatticeGraph</a> (const <a class="el" href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:ab7b459ddc7c532fc5a37abb8760d7ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts the degree set for a lattice graph.  <br /></td></tr>
<tr class="separator:ab7b459ddc7c532fc5a37abb8760d7ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026973ba07ba80213ede65e64a3eb614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d01/graph_assert_functions_8hpp.html#a026973ba07ba80213ede65e64a3eb614">assertGraphNumVertices</a> (const <a class="el" href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a> &amp;graph, int numVertices)</td></tr>
<tr class="memdesc:a026973ba07ba80213ede65e64a3eb614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts the number of vertices in a graph.  <br /></td></tr>
<tr class="separator:a026973ba07ba80213ede65e64a3eb614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3241060bf4552dac98da626843460bb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d01/graph_assert_functions_8hpp.html#a3241060bf4552dac98da626843460bb3">assertFlowFunctionsPerformExpected</a> (const <a class="el" href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a> &amp;graph, int numRows)</td></tr>
<tr class="memdesc:a3241060bf4552dac98da626843460bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that flow functions perform as expected in a graph.  <br /></td></tr>
<tr class="separator:a3241060bf4552dac98da626843460bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3f8d6a6068b10ca7ca8f2f4515cbcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d01/graph_assert_functions_8hpp.html#a5c3f8d6a6068b10ca7ca8f2f4515cbcd">assertNieghbours</a> (const <a class="el" href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a> &amp;graph, std::vector&lt; std::vector&lt; int &gt; &gt; expectedNeighbourhood)</td></tr>
<tr class="memdesc:a5c3f8d6a6068b10ca7ca8f2f4515cbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that the computed neighborhood of each vertex in the graph matches the expected neighborhood.  <br /></td></tr>
<tr class="separator:a5c3f8d6a6068b10ca7ca8f2f4515cbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fc70f2265e3ca43a7871939ae44a95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d01/graph_assert_functions_8hpp.html#a67fc70f2265e3ca43a7871939ae44a95">assertCorrection</a> (const <a class="el" href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a> &amp;graph, std::vector&lt; int &gt; outcomeVector, int vertex, int numRows, qreal inputAngle, qreal expectedCorrectedAngle)</td></tr>
<tr class="memdesc:a67fc70f2265e3ca43a7871939ae44a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that the computed corrected angle matches the expected corrected angle.  <br /></td></tr>
<tr class="separator:a67fc70f2265e3ca43a7871939ae44a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91620d08875164bce42bdc604224ed3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d01/graph_assert_functions_8hpp.html#ab91620d08875164bce42bdc604224ed3">testEveryOtherAnlgeZeroResults</a> (int assertValue, int piDenominator, int numberCols)</td></tr>
<tr class="memdesc:ab91620d08875164bce42bdc604224ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests the measurement outcomes with every other angle set to zero.  <br /></td></tr>
<tr class="separator:ab91620d08875164bce42bdc604224ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a67fc70f2265e3ca43a7871939ae44a95" name="a67fc70f2265e3ca43a7871939ae44a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fc70f2265e3ca43a7871939ae44a95">&#9670;&#160;</a></span>assertCorrection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assertCorrection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>outcomeVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>inputAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>expectedCorrectedAngle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts that the computed corrected angle matches the expected corrected angle. </p>
<p>The function computes the corrected angle using the <code>computeCorrectedAngle</code> function and compares it with the expected corrected angle. It throws an assertion error if the computed corrected angle does not match the expected corrected angle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph representing the lattice. </td></tr>
    <tr><td class="paramname">outcomeVector</td><td>The vector of measured outcomes. </td></tr>
    <tr><td class="paramname">vertex</td><td>The vertex for which the corrected angle is computed. </td></tr>
    <tr><td class="paramname">numRows</td><td>The number of rows in the lattice. </td></tr>
    <tr><td class="paramname">inputAngle</td><td>The input angle for the vertex. </td></tr>
    <tr><td class="paramname">expectedCorrectedAngle</td><td>The expected corrected angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the computed corrected angle does not match the expected corrected angle. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html#l00210">210</a> of file <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html">graphAssertFunctions.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  216</span>                                 {</div>
<div class="line"><span class="lineno">  217</span>        </div>
<div class="line"><span class="lineno">  218</span>        qreal computedCorrectedAngle = <a class="code hl_function" href="../../d0/d01/graph_traversal_flows_8hpp.html#a2b29f1efbcbccfbe77481e5b1a9647c8">computeCorrectedAngle</a>(</div>
<div class="line"><span class="lineno">  219</span>            graph,</div>
<div class="line"><span class="lineno">  220</span>            outcomeVector, </div>
<div class="line"><span class="lineno">  221</span>            vertex,</div>
<div class="line"><span class="lineno">  222</span>            numRows,</div>
<div class="line"><span class="lineno">  223</span>            inputAngle);</div>
<div class="line"><span class="lineno">  224</span>        </div>
<div class="line"><span class="lineno">  225</span>        assert((<span class="stringliteral">&quot;New angle and original angle do not match&quot;</span> &amp;&amp; computedCorrectedAngle == expectedCorrectedAngle));</div>
<div class="line"><span class="lineno">  226</span>}</div>
<div class="ttc" id="agraph_traversal_flows_8hpp_html_a2b29f1efbcbccfbe77481e5b1a9647c8"><div class="ttname"><a href="../../d0/d01/graph_traversal_flows_8hpp.html#a2b29f1efbcbccfbe77481e5b1a9647c8">computeCorrectedAngle</a></div><div class="ttdeci">qreal computeCorrectedAngle(const undirectedGraph &amp;graph, std::vector&lt; int &gt; measuredOutcomes, int vertex, int numRows, qreal angle)</div><div class="ttdoc">Computes the corrected angle based on measured outcomes and flow functions in an undirected graph.</div><div class="ttdef"><b>Definition</b> <a href="../../d0/d01/graph_traversal_flows_8hpp_source.html#l00153">graphTraversalFlows.hpp:153</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab7b459ddc7c532fc5a37abb8760d7ca6" name="ab7b459ddc7c532fc5a37abb8760d7ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b459ddc7c532fc5a37abb8760d7ca6">&#9670;&#160;</a></span>assertDegreeSetLatticeGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assertDegreeSetLatticeGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts the degree set for a lattice graph. </p>
<p>The function checks whether the degrees of all vertices in the provided lattice graph belong to the set {2, 3, 4}. It calculates the degrees of all vertices in the graph and filters out degrees that are not in the required set. It then asserts that all remaining degrees are either 2, 3, or 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The lattice graph to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if a degree outside the set {2, 3, 4} is found. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html#l00094">94</a> of file <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html">graphAssertFunctions.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   94</span>                                                               {</div>
<div class="line"><span class="lineno">   95</span>    </div>
<div class="line"><span class="lineno">   96</span>    <span class="keywordtype">int</span> num_vertices = boost::num_vertices(graph);</div>
<div class="line"><span class="lineno">   97</span>    std::vector&lt;int&gt; degree_vector;</div>
<div class="line"><span class="lineno">   98</span>    std::vector&lt;int&gt; required_deg_vector = {2,3,4};</div>
<div class="line"><span class="lineno">   99</span>    <span class="comment">// Call the function and print the adjacent vertices of vertex 0</span></div>
<div class="line"><span class="lineno">  100</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_vertices; i++) {</div>
<div class="line"><span class="lineno">  101</span>      undirectedGraph::vertex_descriptor v;</div>
<div class="line"><span class="lineno">  102</span>      v = boost::vertex(i, graph); </div>
<div class="line"><span class="lineno">  103</span>      <span class="keywordtype">int</span> d = boost::degree(v, graph);</div>
<div class="line"><span class="lineno">  104</span>      degree_vector.push_back(d);        </div>
<div class="line"><span class="lineno">  105</span>    }</div>
<div class="line"><span class="lineno">  106</span> </div>
<div class="line"><span class="lineno">  107</span>    sort( degree_vector.begin(), degree_vector.end() );</div>
<div class="line"><span class="lineno">  108</span>    </div>
<div class="line"><span class="lineno">  109</span>    degree_vector.erase(std::unique( degree_vector.begin(), degree_vector.end() ), degree_vector.end() );</div>
<div class="line"><span class="lineno">  110</span> </div>
<div class="line"><span class="lineno">  111</span> </div>
<div class="line"><span class="lineno">  112</span>    std::vector&lt;int&gt; filt;</div>
<div class="line"><span class="lineno">  113</span>    std::copy_if(degree_vector.begin(), degree_vector.end(), std::back_inserter(filt), [](<span class="keywordtype">int</span> i) {</div>
<div class="line"><span class="lineno">  114</span>        return i == 2 || i == 3 || i == 4;</div>
<div class="line"><span class="lineno">  115</span>    });</div>
<div class="line"><span class="lineno">  116</span> </div>
<div class="line"><span class="lineno">  117</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> &amp;i: filt) {</div>
<div class="line"><span class="lineno">  118</span>        assert(<span class="stringliteral">&quot;Degree must be either 2,3 or 4&quot;</span> &amp;&amp; i == 2 || i == 3 || i == 4);</div>
<div class="line"><span class="lineno">  119</span>    }</div>
<div class="line"><span class="lineno">  120</span> </div>
<div class="line"><span class="lineno">  121</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3241060bf4552dac98da626843460bb3" name="a3241060bf4552dac98da626843460bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3241060bf4552dac98da626843460bb3">&#9670;&#160;</a></span>assertFlowFunctionsPerformExpected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assertFlowFunctionsPerformExpected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts that flow functions perform as expected in a graph. </p>
<p>The function checks whether the flow functions in the provided graph produce the expected results. It verifies that the computed vertices from the flow functions match the expected vertices based on the graph structure and the specified number of rows. It throws an assertion error if any mismatch is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to check. </td></tr>
    <tr><td class="paramname">numRows</td><td>The number of rows in the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if any computed vertex does not match the expected vertex. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html#l00149">149</a> of file <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html">graphAssertFunctions.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  149</span>                                                                                   {</div>
<div class="line"><span class="lineno">  150</span>    undirectedGraph::vertex_iterator vi, vi_end;</div>
<div class="line"><span class="lineno">  151</span>    <span class="keywordtype">int</span> size_graph = boost::num_vertices(graph);</div>
<div class="line"><span class="lineno">  152</span> </div>
<div class="line"><span class="lineno">  153</span>    <span class="keywordflow">for</span> (boost::tie(vi, vi_end) = boost::vertices(graph); vi != vi_end; ++vi) {</div>
<div class="line"><span class="lineno">  154</span>        <span class="comment">// Skip vertices that are in the first column</span></div>
<div class="line"><span class="lineno">  155</span>        <span class="keywordflow">if</span> (*vi &gt;= numRows) {</div>
<div class="line"><span class="lineno">  156</span>            <span class="keywordtype">int</span> computedVi = <a class="code hl_function" href="../../d0/d01/graph_traversal_flows_8hpp.html#a7b014587f20137aff522774eb1a05947">getLattice2DPastVertexGraph</a>(graph, *vi, numRows);</div>
<div class="line"><span class="lineno">  157</span>            <span class="keywordtype">int</span> expectedVi = *vi - numRows;</div>
<div class="line"><span class="lineno">  158</span>            assert(((expectedVi == computedVi) &amp;&amp; <span class="stringliteral">&quot;Expected vertex does not match computed vertex from getLattice2DPastVertexGraph function&quot;</span>));</div>
<div class="line"><span class="lineno">  159</span>        }</div>
<div class="line"><span class="lineno">  160</span>    }</div>
<div class="line"><span class="lineno">  161</span>    </div>
<div class="line"><span class="lineno">  162</span>    <span class="keywordflow">for</span> (boost::tie(vi, vi_end) = boost::vertices(graph); vi != vi_end; ++vi) {</div>
<div class="line"><span class="lineno">  163</span>        <span class="comment">// Skip vertices that are in the last column</span></div>
<div class="line"><span class="lineno">  164</span>        <span class="keywordflow">if</span> (*vi &lt; (size_graph - numRows)) {</div>
<div class="line"><span class="lineno">  165</span>            <span class="keywordtype">int</span> computedVi = <a class="code hl_function" href="../../d0/d01/graph_traversal_flows_8hpp.html#aafe3849a9ad4cb18d843d73c89936bb3">getLattice2DFutureVertexGraph</a>(graph, *vi, numRows);</div>
<div class="line"><span class="lineno">  166</span>            <span class="keywordtype">int</span> expectedVi = *vi + numRows;</div>
<div class="line"><span class="lineno">  167</span>            assert(((expectedVi == computedVi) &amp;&amp; <span class="stringliteral">&quot;Expected vertex does not match computed vertex from getLattice2DPastVertexGraph function&quot;</span>));</div>
<div class="line"><span class="lineno">  168</span>        }</div>
<div class="line"><span class="lineno">  169</span>    }</div>
<div class="line"><span class="lineno">  170</span>}</div>
<div class="ttc" id="agraph_traversal_flows_8hpp_html_a7b014587f20137aff522774eb1a05947"><div class="ttname"><a href="../../d0/d01/graph_traversal_flows_8hpp.html#a7b014587f20137aff522774eb1a05947">getLattice2DPastVertexGraph</a></div><div class="ttdeci">int getLattice2DPastVertexGraph(const undirectedGraph &amp;graph, int vertex, int numRows)</div><div class="ttdoc">Computes the past vertex in a 2D lattice graph based on a flow function for a given vertex in the gra...</div><div class="ttdef"><b>Definition</b> <a href="../../d0/d01/graph_traversal_flows_8hpp_source.html#l00130">graphTraversalFlows.hpp:130</a></div></div>
<div class="ttc" id="agraph_traversal_flows_8hpp_html_aafe3849a9ad4cb18d843d73c89936bb3"><div class="ttname"><a href="../../d0/d01/graph_traversal_flows_8hpp.html#aafe3849a9ad4cb18d843d73c89936bb3">getLattice2DFutureVertexGraph</a></div><div class="ttdeci">int getLattice2DFutureVertexGraph(const undirectedGraph &amp;graph, int vertex, int numRows)</div><div class="ttdoc">Computes the future vertex in a 2D lattice graph based on a flow function for a given vertex in the g...</div><div class="ttdef"><b>Definition</b> <a href="../../d0/d01/graph_traversal_flows_8hpp_source.html#l00105">graphTraversalFlows.hpp:105</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a026973ba07ba80213ede65e64a3eb614" name="a026973ba07ba80213ede65e64a3eb614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026973ba07ba80213ede65e64a3eb614">&#9670;&#160;</a></span>assertGraphNumVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assertGraphNumVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts the number of vertices in a graph. </p>
<p>The function checks whether the number of vertices in the provided graph matches the expected number of vertices. It compares the actual number of vertices in the graph with the expected number and throws an assertion error if they do not match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to check. </td></tr>
    <tr><td class="paramname">numVertices</td><td>The expected number of vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the number of vertices does not match the expected number. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html#l00133">133</a> of file <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html">graphAssertFunctions.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  133</span>                                                                          {</div>
<div class="line"><span class="lineno">  134</span>  <span class="keywordtype">int</span> num_vertices = boost::num_vertices(graph);</div>
<div class="line"><span class="lineno">  135</span>  assert(<span class="stringliteral">&quot;Number of vertices in graph must equal input&quot;</span> &amp;&amp; numVertices == num_vertices);</div>
<div class="line"><span class="lineno">  136</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a60966966368ac25fe48dbccd70490e98" name="a60966966368ac25fe48dbccd70490e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60966966368ac25fe48dbccd70490e98">&#9670;&#160;</a></span>assertHandShakeLemma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assertHandShakeLemma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts the Handshake Lemma for an undirected graph. </p>
<p>This function asserts the Handshake Lemma for an undirected graph. The Handshake Lemma states that the sum of the degrees of all vertices in an undirected graph is equal to twice the number of edges in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The undirected graph to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the Handshake Lemma is violated. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html">graphAssertFunctions.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   39</span>                                                        {</div>
<div class="line"><span class="lineno">   40</span>    </div>
<div class="line"><span class="lineno">   41</span>    <span class="keywordtype">int</span> num_vertices = boost::num_vertices(graph);</div>
<div class="line"><span class="lineno">   42</span>    boost::container::vector&lt;int&gt; degree_vector;</div>
<div class="line"><span class="lineno">   43</span> </div>
<div class="line"><span class="lineno">   44</span>    <span class="comment">// Call the function and print the adjacent vertices of vertex 0</span></div>
<div class="line"><span class="lineno">   45</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_vertices; i++) {</div>
<div class="line"><span class="lineno">   46</span>      undirectedGraph::vertex_descriptor v;</div>
<div class="line"><span class="lineno">   47</span>      v = boost::vertex(i, graph); </div>
<div class="line"><span class="lineno">   48</span>      degree_vector.push_back(boost::degree(v, graph));        </div>
<div class="line"><span class="lineno">   49</span>    }</div>
<div class="line"><span class="lineno">   50</span> </div>
<div class="line"><span class="lineno">   51</span>    <span class="keywordtype">int</span> num_edge = boost::num_edges(graph);   </div>
<div class="line"><span class="lineno">   52</span>    <span class="keywordtype">int</span> sum = std::accumulate(degree_vector.begin(), degree_vector.end(), 0);</div>
<div class="line"><span class="lineno">   53</span>    assert((<span class="stringliteral">&quot;total degree is two times the edge set&quot;</span> &amp;&amp; sum == 2 * num_edge));</div>
<div class="line"><span class="lineno">   54</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5c3f8d6a6068b10ca7ca8f2f4515cbcd" name="a5c3f8d6a6068b10ca7ca8f2f4515cbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3f8d6a6068b10ca7ca8f2f4515cbcd">&#9670;&#160;</a></span>assertNieghbours()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assertNieghbours </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td>
          <td class="paramname"><em>expectedNeighbourhood</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts that the computed neighborhood of each vertex in the graph matches the expected neighborhood. </p>
<p>The function checks whether the computed neighborhood of each vertex in the provided graph matches the expected neighborhood specified in <code>expectedNeighbourhood</code>. It throws an assertion error if any mismatch is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to check. </td></tr>
    <tr><td class="paramname">expectedNeighbourhood</td><td>The expected neighborhood for each vertex. The outer vector represents vertices, and the inner vectors represent their respective neighborhoods. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if any computed neighborhood does not match the expected neighborhood. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html#l00181">181</a> of file <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html">graphAssertFunctions.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  181</span>                                                                                                   {        </div>
<div class="line"><span class="lineno">  182</span>    <span class="keywordtype">int</span> size_graph = boost::num_vertices(graph);</div>
<div class="line"><span class="lineno">  183</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> vertexIter = 0; vertexIter &lt; size_graph; vertexIter++){</div>
<div class="line"><span class="lineno">  184</span>        std::vector&lt;int&gt; computedNeighbours = <a class="code hl_function" href="../../d0/d01/graph_traversal_flows_8hpp.html#a954183dad806b30b05e526c37284768b">getVertexNeighbours</a>(graph,vertexIter);</div>
<div class="line"><span class="lineno">  185</span>        std::vector&lt;int&gt; expectedNeighbours;</div>
<div class="line"><span class="lineno">  186</span>        expectedNeighbours = expectedNeighbourhood[vertexIter];</div>
<div class="line"><span class="lineno">  187</span>    </div>
<div class="line"><span class="lineno">  188</span>        std::sort(expectedNeighbours.begin(), expectedNeighbours.end());</div>
<div class="line"><span class="lineno">  189</span>        std::sort(computedNeighbours.begin(), computedNeighbours.end());</div>
<div class="line"><span class="lineno">  190</span>        assert(expectedNeighbours.size() == computedNeighbours.size() &amp;&amp; std::equal(expectedNeighbours.begin(), expectedNeighbours.end(), computedNeighbours.begin()));</div>
<div class="line"><span class="lineno">  191</span>    }</div>
<div class="line"><span class="lineno">  192</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  193</span>}</div>
<div class="ttc" id="agraph_traversal_flows_8hpp_html_a954183dad806b30b05e526c37284768b"><div class="ttname"><a href="../../d0/d01/graph_traversal_flows_8hpp.html#a954183dad806b30b05e526c37284768b">getVertexNeighbours</a></div><div class="ttdeci">std::vector&lt; int &gt; getVertexNeighbours(const undirectedGraph &amp;graph, int vertex)</div><div class="ttdoc">Retrieves the neighboring vertices of a given vertex in an undirected graph.</div><div class="ttdef"><b>Definition</b> <a href="../../d0/d01/graph_traversal_flows_8hpp_source.html#l00077">graphTraversalFlows.hpp:77</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a781ea29934c2f8c5c65a73075bc13da1" name="a781ea29934c2f8c5c65a73075bc13da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781ea29934c2f8c5c65a73075bc13da1">&#9670;&#160;</a></span>assertPathGraphMinMaxDegrees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assertPathGraphMinMaxDegrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts the minimum and maximum degrees for a path graph. </p>
<p>This function asserts that the minimum degree of a path graph is 1 and the maximum degree is 2. It calculates the degrees of all vertices in the provided graph and checks if the minimum degree is 1 and the maximum degree is 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The path graph to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the minimum or maximum degree is violated. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html#l00066">66</a> of file <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html">graphAssertFunctions.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   66</span>                                                                {</div>
<div class="line"><span class="lineno">   67</span>    <span class="keywordtype">int</span> num_vertices = boost::num_vertices(graph);</div>
<div class="line"><span class="lineno">   68</span>    boost::container::vector&lt;int&gt; degree_vector;</div>
<div class="line"><span class="lineno">   69</span> </div>
<div class="line"><span class="lineno">   70</span>    <span class="comment">// Calculate the degree of each vertex</span></div>
<div class="line"><span class="lineno">   71</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_vertices; i++) {</div>
<div class="line"><span class="lineno">   72</span>        undirectedGraph::vertex_descriptor v;</div>
<div class="line"><span class="lineno">   73</span>        v = boost::vertex(i, graph);</div>
<div class="line"><span class="lineno">   74</span>        degree_vector.push_back(boost::degree(v, graph));</div>
<div class="line"><span class="lineno">   75</span>    }</div>
<div class="line"><span class="lineno">   76</span> </div>
<div class="line"><span class="lineno">   77</span>    <span class="keywordtype">int</span> min_degree = <a class="code hl_function" href="../../d3/d01/general_assert_functions_8hpp.html#aaa5eeda4e79aa986d57c3256556b6e6c">getMin</a>(degree_vector);</div>
<div class="line"><span class="lineno">   78</span>    assert((<span class="stringliteral">&quot;minimum degree is 1&quot;</span> &amp;&amp; min_degree == 1));</div>
<div class="line"><span class="lineno">   79</span>    <span class="keywordtype">int</span> max_degree = <a class="code hl_function" href="../../d3/d01/general_assert_functions_8hpp.html#af227e83a7360ec64f91773c37a905253">getMax</a>(degree_vector);</div>
<div class="line"><span class="lineno">   80</span>    assert((<span class="stringliteral">&quot;maximum degree is 2&quot;</span> &amp;&amp; max_degree == 2));</div>
<div class="line"><span class="lineno">   81</span>}</div>
<div class="ttc" id="ageneral_assert_functions_8hpp_html_aaa5eeda4e79aa986d57c3256556b6e6c"><div class="ttname"><a href="../../d3/d01/general_assert_functions_8hpp.html#aaa5eeda4e79aa986d57c3256556b6e6c">getMin</a></div><div class="ttdeci">int getMin(const boost::container::vector&lt; int &gt; &amp;vec)</div><div class="ttdoc">Retrieves the minimum value from a vector.</div><div class="ttdef"><b>Definition</b> <a href="../../d3/d01/general_assert_functions_8hpp_source.html#l00038">generalAssertFunctions.hpp:38</a></div></div>
<div class="ttc" id="ageneral_assert_functions_8hpp_html_af227e83a7360ec64f91773c37a905253"><div class="ttname"><a href="../../d3/d01/general_assert_functions_8hpp.html#af227e83a7360ec64f91773c37a905253">getMax</a></div><div class="ttdeci">int getMax(const boost::container::vector&lt; int &gt; &amp;vec)</div><div class="ttdoc">Retrieves the maximum value from a vector.</div><div class="ttdef"><b>Definition</b> <a href="../../d3/d01/general_assert_functions_8hpp_source.html#l00064">generalAssertFunctions.hpp:64</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab91620d08875164bce42bdc604224ed3" name="ab91620d08875164bce42bdc604224ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91620d08875164bce42bdc604224ed3">&#9670;&#160;</a></span>testEveryOtherAnlgeZeroResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void testEveryOtherAnlgeZeroResults </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>assertValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>piDenominator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests the measurement outcomes with every other angle set to zero. </p>
<p>This function performs a test where the measurement outcomes are checked based on the specified assert value, pi denominator, and number of columns. The function initializes variables, sets values, creates a quantum register, sets angles, entangles the graph, measures the graph, and unloads QuEST.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assertValue</td><td>The expected value for the measurement outcomes. </td></tr>
    <tr><td class="paramname">piDenominator</td><td>The denominator for the angles in the range [0, 2*pi). </td></tr>
    <tr><td class="paramname">numberCols</td><td>The number of columns in the lattice. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html#l00240">240</a> of file <a class="el" href="../../d0/d01/graph_assert_functions_8hpp_source.html">graphAssertFunctions.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  240</span>                                                                                     {</div>
<div class="line"><span class="lineno">  241</span>    <span class="comment">// Initialise variable names and types</span></div>
<div class="line"><span class="lineno">  242</span>    <span class="keywordtype">int</span> numRows;</div>
<div class="line"><span class="lineno">  243</span>    <span class="keywordtype">int</span> numCols;</div>
<div class="line"><span class="lineno">  244</span>    <a class="code hl_typedef" href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a> latticeGraph;</div>
<div class="line"><span class="lineno">  245</span>    <span class="keywordtype">int</span> numVertices;</div>
<div class="line"><span class="lineno">  246</span>    std::vector&lt;qreal&gt; qubitAngles;</div>
<div class="line"><span class="lineno">  247</span>    std::vector&lt;int&gt; measuredQubitsOutcomes;</div>
<div class="line"><span class="lineno">  248</span>    </div>
<div class="line"><span class="lineno">  249</span> </div>
<div class="line"><span class="lineno">  250</span> </div>
<div class="line"><span class="lineno">  251</span>    <span class="comment">// Set values to variables</span></div>
<div class="line"><span class="lineno">  252</span>    numRows = 1;</div>
<div class="line"><span class="lineno">  253</span>    numCols = numberCols; <span class="comment">// Test on an odd number of qubits</span></div>
<div class="line"><span class="lineno">  254</span>    latticeGraph = <a class="code hl_function" href="../../db/d00/graph_constructions_8hpp.html#a74f9014929a19ec558c3bc766754f1c3">createLatticeGraph</a>(numRows,numCols);</div>
<div class="line"><span class="lineno">  255</span>    numVertices = boost::num_vertices(latticeGraph);</div>
<div class="line"><span class="lineno">  256</span> </div>
<div class="line"><span class="lineno">  257</span> </div>
<div class="line"><span class="lineno">  258</span>    <span class="comment">// load QuEST environment</span></div>
<div class="line"><span class="lineno">  259</span>    QuESTEnv env = createQuESTEnv();</div>
<div class="line"><span class="lineno">  260</span> </div>
<div class="line"><span class="lineno">  261</span> </div>
<div class="line"><span class="lineno">  262</span>    <span class="comment">// create a quantum register</span></div>
<div class="line"><span class="lineno">  263</span>    Qureg qureg = createQureg(numVertices, env);</div>
<div class="line"><span class="lineno">  264</span> </div>
<div class="line"><span class="lineno">  265</span>    </div>
<div class="line"><span class="lineno">  266</span> </div>
<div class="line"><span class="lineno">  267</span>    <span class="comment">// set angles</span></div>
<div class="line"><span class="lineno">  268</span>    </div>
<div class="line"><span class="lineno">  269</span>    <span class="keywordflow">if</span> (assertValue == 0){</div>
<div class="line"><span class="lineno">  270</span>        qubitAngles = <a class="code hl_function" href="../../d3/d00/angle_construction_8hpp.html#a0804b07ffb2bea2c7ac8cba482a88d62">initRandomPiOnNEveryOtherAnglesMod2kPi</a>(numVertices,piDenominator); <span class="comment">// end in 0</span></div>
<div class="line"><span class="lineno">  271</span>    }<span class="keywordflow">else</span> <span class="keywordflow">if</span> (assertValue == 1){</div>
<div class="line"><span class="lineno">  272</span>        qubitAngles = <a class="code hl_function" href="../../d3/d00/angle_construction_8hpp.html#ac35939429a8657a1f33dad419e7812c1">initRandomPiOnNEveryOtherAnglesMod2kPiPlusPi</a>(numVertices,piDenominator);  <span class="comment">// end in 1</span></div>
<div class="line"><span class="lineno">  273</span>    }<span class="keywordflow">else</span>{</div>
<div class="line"><span class="lineno">  274</span>        <span class="comment">// Nothing</span></div>
<div class="line"><span class="lineno">  275</span>    }</div>
<div class="line"><span class="lineno">  276</span> </div>
<div class="line"><span class="lineno">  277</span>    </div>
<div class="line"><span class="lineno">  278</span>    <span class="comment">// initialise in the plus state</span></div>
<div class="line"><span class="lineno">  279</span>    initPlusState(qureg);</div>
<div class="line"><span class="lineno">  280</span> </div>
<div class="line"><span class="lineno">  281</span>    <span class="comment">//Leave angle off qubits</span></div>
<div class="line"><span class="lineno">  282</span>    <span class="comment">// add angles to the qubits</span></div>
<div class="line"><span class="lineno">  283</span>    <span class="comment">//addAngleRotateZgate(qureg,qubitAngles);</span></div>
<div class="line"><span class="lineno">  284</span> </div>
<div class="line"><span class="lineno">  285</span> </div>
<div class="line"><span class="lineno">  286</span>    <span class="comment">// entangle graph</span></div>
<div class="line"><span class="lineno">  287</span>    <a class="code hl_function" href="../../dc/d00/quantum_graph_cluster_states_8hpp.html#a3f830234f9eb3a150a084b0f2b4aa056">entangleGraph</a>(qureg,latticeGraph);</div>
<div class="line"><span class="lineno">  288</span> </div>
<div class="line"><span class="lineno">  289</span> </div>
<div class="line"><span class="lineno">  290</span>    <span class="comment">// measure graph</span></div>
<div class="line"><span class="lineno">  291</span>    measuredQubitsOutcomes = <a class="code hl_function" href="../../de/d00/flow_measurements_8hpp.html#a7231be9a1c347894c1d01c349f4b41c7">measureGraph</a>(</div>
<div class="line"><span class="lineno">  292</span>        qureg,</div>
<div class="line"><span class="lineno">  293</span>        latticeGraph,</div>
<div class="line"><span class="lineno">  294</span>        qubitAngles,</div>
<div class="line"><span class="lineno">  295</span>        numRows);</div>
<div class="line"><span class="lineno">  296</span> </div>
<div class="line"><span class="lineno">  297</span>    </div>
<div class="line"><span class="lineno">  298</span>    <span class="comment">// unload QuEST</span></div>
<div class="line"><span class="lineno">  299</span>    destroyQureg(qureg, env); </div>
<div class="line"><span class="lineno">  300</span>    destroyQuESTEnv(env);</div>
<div class="line"><span class="lineno">  301</span>}</div>
<div class="ttc" id="aangle_construction_8hpp_html_a0804b07ffb2bea2c7ac8cba482a88d62"><div class="ttname"><a href="../../d3/d00/angle_construction_8hpp.html#a0804b07ffb2bea2c7ac8cba482a88d62">initRandomPiOnNEveryOtherAnglesMod2kPi</a></div><div class="ttdeci">std::vector&lt; qreal &gt; initRandomPiOnNEveryOtherAnglesMod2kPi(int numQubits, int piDenominator)</div><div class="ttdoc">Initializes a vector of qreal values with random angles, where every other angle is set to 0.</div><div class="ttdef"><b>Definition</b> <a href="../../d3/d00/angle_construction_8hpp_source.html#l00205">angleConstruction.hpp:205</a></div></div>
<div class="ttc" id="aangle_construction_8hpp_html_ac35939429a8657a1f33dad419e7812c1"><div class="ttname"><a href="../../d3/d00/angle_construction_8hpp.html#ac35939429a8657a1f33dad419e7812c1">initRandomPiOnNEveryOtherAnglesMod2kPiPlusPi</a></div><div class="ttdeci">std::vector&lt; qreal &gt; initRandomPiOnNEveryOtherAnglesMod2kPiPlusPi(int numQubits, int piDenominator)</div><div class="ttdoc">Initializes a vector of qreal values with random angles, where every other angle is set to 0.</div><div class="ttdef"><b>Definition</b> <a href="../../d3/d00/angle_construction_8hpp_source.html#l00264">angleConstruction.hpp:264</a></div></div>
<div class="ttc" id="aflow_measurements_8hpp_html_a7231be9a1c347894c1d01c349f4b41c7"><div class="ttname"><a href="../../de/d00/flow_measurements_8hpp.html#a7231be9a1c347894c1d01c349f4b41c7">measureGraph</a></div><div class="ttdeci">std::vector&lt; int &gt; measureGraph(Qureg qureg, const undirectedGraph &amp;graph, std::vector&lt; qreal &gt; qubitAngles, int numRows)</div><div class="ttdoc">Measures qubits in a graph-based quantum state.</div><div class="ttdef"><b>Definition</b> <a href="../../de/d00/flow_measurements_8hpp_source.html#l00057">flowMeasurements.hpp:57</a></div></div>
<div class="ttc" id="agraph_constructions_8hpp_html_a74f9014929a19ec558c3bc766754f1c3"><div class="ttname"><a href="../../db/d00/graph_constructions_8hpp.html#a74f9014929a19ec558c3bc766754f1c3">createLatticeGraph</a></div><div class="ttdeci">undirectedGraph createLatticeGraph(int numRows, int numCols)</div><div class="ttdoc">Creates an undirected lattice graph with the specified number of rows and columns.</div><div class="ttdef"><b>Definition</b> <a href="../../db/d00/graph_constructions_8hpp_source.html#l00054">graphConstructions.hpp:54</a></div></div>
<div class="ttc" id="apackages_8hpp_html_adb6c610c60479e8b904f5832786b4125"><div class="ttname"><a href="../../de/d01/packages_8hpp.html#adb6c610c60479e8b904f5832786b4125">undirectedGraph</a></div><div class="ttdeci">boost::adjacency_list&lt; boost::vecS, boost::vecS, boost::undirectedS, boost::property&lt; boost::vertex_index_t, int &gt;, boost::property&lt; boost::edge_index_t, int &gt; &gt; undirectedGraph</div><div class="ttdoc">Alias for an undirected graph using boost::adjacency_list.</div><div class="ttdef"><b>Definition</b> <a href="../../de/d01/packages_8hpp_source.html#l00067">packages.hpp:73</a></div></div>
<div class="ttc" id="aquantum_graph_cluster_states_8hpp_html_a3f830234f9eb3a150a084b0f2b4aa056"><div class="ttname"><a href="../../dc/d00/quantum_graph_cluster_states_8hpp.html#a3f830234f9eb3a150a084b0f2b4aa056">entangleGraph</a></div><div class="ttdeci">void entangleGraph(Qureg qureg, const undirectedGraph &amp;graph)</div><div class="ttdef"><b>Definition</b> <a href="../../dc/d00/quantum_graph_cluster_states_8hpp_source.html#l00012">quantumGraphClusterStates.hpp:12</a></div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="../../dir_5e94d188cba95e774cdc9d0c259e64a6.html">testFunctions</a></li><li class="navelem"><a class="el" href="../../d0/d01/graph_assert_functions_8hpp.html">graphAssertFunctions.hpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
