<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MBQC: MBQC</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../mbqc_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">MBQC<span id="projectnumber">&#160;0.01</span>
   </div>
   <div id="projectbrief">Measurement Based Quantum Computation (MBQC) using QuEST</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">MBQC</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> </p>
<h1><a class="anchor" id="autotoc_md1"></a>
Measurement Based Quantum Computation</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Linear Cluster</h2>
<h3><a class="anchor" id="autotoc_md3"></a>
Used this libraries</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;QuEST.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md4"></a>
Create a linear cluster</h3>
<p>Create vector of digits from $0$ to $N-1$, separated by $1$ to represent a cluster state by a line of nodes connected by edges, similar to this asci art <code>()-()-()- - - -()</code> where each <code>()</code> represent a node or a qubit when this structure is used to generate the cluster state of qubits. $(0,2,3,...,N-1)$</p>
<div class="fragment"><div class="line">vector&lt;int&gt; getPathGraph(<span class="keywordtype">int</span> numberQubits)</div>
<div class="line">{</div>
<div class="line">  vector&lt;int&gt; pathGraph;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numberQubits; i++ )</div>
<div class="line">  {</div>
<div class="line">    pathGraph.push_back(i);  </div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> pathGraph;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md5"></a>
Flow function</h3>
<p>Linear cluster state flow is defined as, $f(i) = i + 1$, where $i$ is the current qubit. Consider the graph as a line of qubits, then the flow foward is the next qubit according to the labelled index.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> getFutureQubit(<span class="keywordtype">int</span> currentQubit){</div>
<div class="line">  <span class="keywordtype">int</span> futureQubit;</div>
<div class="line">  futureQubit = currentQubit + 1;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> futureQubit;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Linear flow backwards is defined as, $f^{-1}(i) = i - 1$.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> getPastQubit(<span class="keywordtype">int</span> currentQubit){</div>
<div class="line">  <span class="keywordtype">int</span> pastQubit;</div>
<div class="line">  pastQubit = currentQubit - 1;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> pastQubit;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Linear cluster vector with the flow, $f$, $f(i) = i + 1$, if $i$ is last element of vector, then throw error.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> getFutureQubitPathGraph(vector&lt;int&gt; pathGraph ,<span class="keywordtype">int</span> currentQubit)</div>
<div class="line">{</div>
<div class="line"><span class="keywordtype">int</span> futureQubit;</div>
<div class="line"><span class="keyword">auto</span> graphSize = pathGraph.size();</div>
<div class="line"><span class="keywordflow">if</span> (currentQubit == pathGraph[graphSize-1]) {</div>
<div class="line">    assert(currentQubit != pathGraph[graphSize-1] &amp;&amp; <span class="stringliteral">&quot;No past qubit here, re-check your program&quot;</span>);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  futureQubit = getFutureQubit(currentQubit);</div>
<div class="line">}</div>
<div class="line">  <span class="keywordflow">return</span> futureQubit;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Linear cluster vector with the flow, $f$, $f^{-1}(i) = i - 1$, if $i$ is first element of vector, then throw error.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> getPastQubitPathGraph(vector&lt;int&gt; pathGraph ,<span class="keywordtype">int</span> currentQubit)</div>
<div class="line">{</div>
<div class="line"><span class="keywordtype">int</span> pastQubit;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (currentQubit == pathGraph[0]) {</div>
<div class="line">  assert(currentQubit != pathGraph[0] &amp;&amp; <span class="stringliteral">&quot;No past qubit here, re-check your program&quot;</span>);</div>
<div class="line"> </div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  pastQubit = getPastQubit(currentQubit);</div>
<div class="line">}</div>
<div class="line">  <span class="keywordflow">return</span> pastQubit;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md6"></a>
Neighborhood</h3>
<p>The neighbor set in a cluster state is technically the open neighbours set, as we do not consider the present or current qubit. Here we get the neighbourhood size by looking at the linear cluster state vector and the current qubit. The logic determines if there are $1$ or $2$ neighbours to the current qubit, based on the qubit position in the linear cluster.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> getOpenNeighbourhoodSizePathGraph(vector&lt;int&gt; pathGraph ,<span class="keywordtype">int</span> currentQubit){</div>
<div class="line">  <span class="keyword">auto</span> graphSize = pathGraph.size();</div>
<div class="line">  <span class="keywordtype">int</span> neighbourhoodSize;</div>
<div class="line">  <span class="comment">// Logic for getting nieghbors</span></div>
<div class="line">  <span class="keywordflow">if</span> (currentQubit == 0) { <span class="comment">// qubit is first</span></div>
<div class="line">    neighbourhoodSize = 1;</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentQubit == pathGraph[graphSize-1]) { <span class="comment">// qubit is last</span></div>
<div class="line">    neighbourhoodSize = 1;</div>
<div class="line">  } <span class="keywordflow">else</span> { <span class="comment">// all else</span></div>
<div class="line">    neighbourhoodSize = 2;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> neighbourhoodSize;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Get the neighbor set of qubits based on the linear cluster and the current qubit</p>
<div class="fragment"><div class="line">vector&lt;int&gt; getOpenNeighbourhoodPathGraph(vector&lt;int&gt; pathGraph ,<span class="keywordtype">int</span> currentQubit){</div>
<div class="line">  vector&lt;int&gt; neighbours;</div>
<div class="line">  <span class="keyword">auto</span> graphSize = pathGraph.size();</div>
<div class="line">  <span class="keywordtype">int</span> firstQubit;</div>
<div class="line">  <span class="keywordtype">int</span> pastQubit;</div>
<div class="line">  <span class="keywordtype">int</span> futureQubit;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (currentQubit == pathGraph[0]) { <span class="comment">// qubit is first in graph</span></div>
<div class="line">    firstQubit = currentQubit + 1;</div>
<div class="line">    neighbours.push_back(firstQubit);</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentQubit == pathGraph[graphSize-1]) { <span class="comment">// qubit is last in graph</span></div>
<div class="line">    firstQubit = currentQubit - 1;</div>
<div class="line">    neighbours.push_back(firstQubit);</div>
<div class="line">  } <span class="keywordflow">else</span> { <span class="comment">// all else</span></div>
<div class="line">    pastQubit = currentQubit - 1;</div>
<div class="line">    futureQubit = currentQubit + 1;</div>
<div class="line">    neighbours.push_back(pastQubit);</div>
<div class="line">    neighbours.push_back(futureQubit);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> neighbours;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
